<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鹦鹉螺</title>
  
  <subtitle>即使成功无望 我亦欣然上场</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ThisNautilus.github.io/"/>
  <updated>2019-08-10T00:34:57.837Z</updated>
  <id>https://ThisNautilus.github.io/</id>
  
  <author>
    <name>鹦鹉螺</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Vue学习】组件传值</title>
    <link href="https://ThisNautilus.github.io/2019/07/10/vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>https://ThisNautilus.github.io/2019/07/10/vue学习之二组件之间的数据传递/</id>
    <published>2019-07-10T14:13:12.000Z</published>
    <updated>2019-08-10T00:34:57.837Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 的组件作用域都是孤立的，不允许在子组件的模板内直接引用父组件的数据。必须使用特定的方法才能实现组件之间的数据传递。</p><a id="more"></a><p>首先用 vue-cli 创建一个项目，其中 App.vue 是父组件，components 文件夹下都是子组件。</p><p><a href="https://www.hualigs.cn/image/nkz33" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/1b194dea7f1bd2062ab55d9dd5cc9c83.png" alt="1b194dea7f1bd2062ab55d9dd5cc9c83.png"></a></p><p><strong>一、父组件向子组件传递数据</strong></p><p>在 Vue 中，可以使用 props 向子组件传递数据。</p><p>子组件部分：</p><p><a href="https://www.hualigs.cn/image/nkAES" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/dec832f4ca2c7874f76ca836bf50b0f3.png" alt="dec832f4ca2c7874f76ca836bf50b0f3.png"></a></p><p>这是 header.vue 的 HTML 部分，logo 是在 data 中定义的变量。</p><p>如果需要从父组件获取 logo 的值，就需要使用 <strong>props: [‘logo’]</strong></p><p><a href="https://www.hualigs.cn/image/nkBfE" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/9dda5e3011f8c5cf50fef7cbe6ff03d8.png" alt="9dda5e3011f8c5cf50fef7cbe6ff03d8.png"></a>**</p><p><strong>在 props 中添加了元素之后，就不需要在 data 中再添加变量了</strong></p><p> 父组件部分：</p><p><a href="https://www.hualigs.cn/image/nkkDg" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/b4e15952b763cbee6cb6891bb5d942b0.png" alt="b4e15952b763cbee6cb6891bb5d942b0.png"></a></p><p>在调用组件的时候，使用 v-bind 将 logo 的值绑定为 App.vue 中定义的变量 logoMsg</p><p><a href="https://www.hualigs.cn/image/nkobe" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/49e1bd2f416f21badd1174bbe605f595.png" alt="49e1bd2f416f21badd1174bbe605f595.png"></a></p><p>然后就能将App.vue中 logoMsg 的值传给 header.vue 了：</p><p><a href="https://www.hualigs.cn/image/nkFOp" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/25bf92955b29400de0c2b605f38720b7.png" alt="25bf92955b29400de0c2b605f38720b7.png"></a></p><p><strong>二、子组件向父组件传递数据</strong></p><p> 子组件主要通过事件传递数据给父组件</p><p>子组件部分：</p><p> <a href="https://www.hualigs.cn/image/nkOa0" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/f3902b1193658f7f05a25a04dc01c7ba.png" alt="f3902b1193658f7f05a25a04dc01c7ba.png"></a></p><p>这是 login.vue 的 HTML 部分，当<input>的值发生变化的时候，将 username 传递给 App.vue</p><p>首先声明一个了方法 setUser，用 change 事件来调用 setUser</p><p><a href="https://www.hualigs.cn/image/nkvVt" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/53396957228b2504b8a41074a76bd832.png" alt="53396957228b2504b8a41074a76bd832.png"></a></p><p>在 setUser 中，使用了 <strong>$emit</strong> 来遍历 transferUser 事件，并返回 this.username</p><p>其中 transferUser 是一个自定义的事件，功能类似于一个中转，this.username 将通过这个事件传递给父组件 </p><p>父组件部分：</p><p><a href="https://www.hualigs.cn/image/nk9Ac" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/22cbbe0fa633525b9d3fd7336a9770f5.png" alt="22cbbe0fa633525b9d3fd7336a9770f5.png"></a></p><p>在父组件 App.vue 中，声明了一个方法 getUser，用 transferUser 事件调用 getUser 方法，获取到从子组件传递过来的参数 username</p><p><a href="https://www.hualigs.cn/image/nkY7a" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/ac7e5c7c18ec1371ff208f40b645f3da.png" alt="ac7e5c7c18ec1371ff208f40b645f3da.png"></a></p><p>getUser 方法中的参数 msg 就是从子组件传递过来的参数 username</p><p><a href="https://www.hualigs.cn/image/nkf3k" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/59d1a9a8886d666ee2262c6f9790dcf5.gif" alt="59d1a9a8886d666ee2262c6f9790dcf5.gif"></a></p><p><strong>三、子组件向子组件传递数据</strong></p><p>Vue 没有直接子对子传参的方法，建议将需要传递数据的子组件，都合并为一个组件。如果一定需要子对子传参，可以先从传到父组件，再传到子组件。</p><p>为了便于开发，Vue 推出了一个<a href="http://www.cnblogs.com/wisewrong/p/6344390.html" target="_blank" rel="noopener">状态管理工具 Vuex</a>，可以很方便实现组件之间的参数传递。</p><blockquote><p>转载自：<a href="https://www.cnblogs.com/wisewrong/p/6266038.html" target="_blank" rel="noopener">https://www.cnblogs.com/wisewrong/p/6266038.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 的组件作用域都是孤立的，不允许在子组件的模板内直接引用父组件的数据。必须使用特定的方法才能实现组件之间的数据传递。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://ThisNautilus.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://ThisNautilus.github.io/tags/vue/"/>
    
      <category term="组件传值" scheme="https://ThisNautilus.github.io/tags/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>【Vue学习】vue-cli 3.x搭建项目</title>
    <link href="https://ThisNautilus.github.io/2019/07/10/vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80vue-cli%203.x%20%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <id>https://ThisNautilus.github.io/2019/07/10/vue学习之一vue-cli 3.x 搭建项目/</id>
    <published>2019-07-10T13:13:12.000Z</published>
    <updated>2019-08-10T00:31:26.917Z</updated>
    
    <content type="html"><![CDATA[<p>Vue Cli 3 官方文档：<a href="https://cli.vuejs.org/zh/guide/" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/</a></p><p><strong>一、安装 @vue/cli</strong></p><p>更新到 3.x 之后，vue-cli 的包名从 vue-cli 改成了 @vue/cli</p><p><strong>如果之前全局安装了旧版本的 vue-cli (1.x 或 2.x)，首先需要使用以下命令卸载掉</strong></p><blockquote><p> 如果没有安装旧版本的 vue-cli 可以跳过卸载直接安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall vue-cli -g</span><br><span class="line"># OR</span><br><span class="line">yarn global remove vue-cli</span><br></pre></td></tr></table></figure><p>然后重新安装新版本的 @vue/cli</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"># OR</span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure><a id="more"></a><p>安装完成后，可以使用 vue -V （这个 V 是大写的）查看版本号</p><p><a href="https://www.hualigs.cn/image/nk86F" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/b567597e0ad7fb1cbed80fbfaf655c65.png" alt="b567597e0ad7fb1cbed80fbfaf655c65.png"></a></p><p><strong>二、创建项目的三种方式</strong></p><p>1.x 和 2.x 的的 vue-cli 采用 init 命令创建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack project-name</span><br></pre></td></tr></table></figure><p>3.x 也支持这种方式，<strong>其运行结果和以前一样</strong></p><p>vue/cli 3.x 还新增了<strong>图形化</strong>的方式来创建项目</p><p>首先还是得在<strong>指定目录</strong>下打开终端，然后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><p>然后浏览器会打开一个页面，可以按照页面将的引导创建项目</p><p>不过我习惯使用命令行工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create project-name</span><br></pre></td></tr></table></figure><p>这里的 project-name 是自定义的项目名称，命令执行之后，会生成对应文件夹</p><p><strong>三、参数详解</strong></p><p>使用 <strong>create</strong> 命令创建项目的时候，有很多配置项需要选择</p><p><strong>如果对某项配置项不熟悉，可以直接选择第一个选项</strong></p><p>首先需要选择模块</p><p><a href="https://www.hualigs.cn/image/nk4bN" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/4f6259c6a558493ef4adf1ad2da9e0ae.png" alt="4f6259c6a558493ef4adf1ad2da9e0ae.png"></a></p><p>如果选择默认选项 default，将会构建一个最基本的 vue 项目（没有 vue-router 也没有 vuex）</p><p>这里推荐选择第二项 Manually select features</p><p>然后根据自己的需求，使用<strong>空格键</strong>选择具体的模块</p><p><a href="https://www.hualigs.cn/image/nkmeL" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/c48151ac87059139b117fb05006f2da9.png" alt="c48151ac87059139b117fb05006f2da9.png"></a></p><p>如果不熟悉上面的模块分别代表什么，可以先按照上图的示意勾选模块</p><p>这样就会创建一个包含 vue-router、vuex 和 postcss 的项目</p><p>勾选之后，使用<strong>回车键</strong>进入下一步</p><p><a href="https://www.hualigs.cn/image/nkbEb" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/0f93bea286dc92f41808d2c42c8349d4.png" alt="0f93bea286dc92f41808d2c42c8349d4.png"></a></p><p>这里需要选择路由模式，yes 是 history 模式，no 是 hash 模式</p><p>萌新可以先从 hash 模式入手，不过实际项目通常采用 history 模式</p><p>然后选择一个合适 CSS 的预编译工具</p><p><a href="https://www.hualigs.cn/image/nkGr9" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/b77ca388bc4d2b9a2106eb2df02ea108.png" alt="b77ca388bc4d2b9a2106eb2df02ea108.png"></a> </p><p>都不熟悉的话就选 <strong>sass</strong> 或者 <strong>less</strong>，因为 stylus 不支持原生 CSS 写法</p><p>后面还需要选择 ESLint 的校验规则，格式化的时机，和各个插件的配置项的位置，不熟悉的话就选第一个</p><p>然后就有了这样的过程：</p><p><a href="https://www.hualigs.cn/image/nkJFh" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/b5a4522ddc30c04eeb8ebf82296661b9.png" alt="b5a4522ddc30c04eeb8ebf82296661b9.png"></a></p><p>最后选择是否将配置项保存为预设，然后配置完成，开始生成项目</p><p>项目生成之后，已经自动安装了相关的依赖项，这时候可以直接启动项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p><strong>四、vue.config.js</strong></p><p>完成以上步骤之后，就已经可以开发 vue 项目了，但无法满足定制化的开发需求</p><p>这时候就需要<strong>手动创建</strong>一个 <strong>vue.config.js，</strong>官方的配置文档可以<a href="https://cli.vuejs.org/zh/config/" target="_blank" rel="noopener">参考这里</a></p><p>这里我贴一个常用的 vue.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  baseUrl: <span class="string">'/'</span>,</span><br><span class="line">  outputDir: <span class="string">'dist'</span>, <span class="comment">// 打包的目录</span></span><br><span class="line">  lintOnSave: <span class="literal">true</span>, <span class="comment">// 在保存时校验格式</span></span><br><span class="line">  productionSourceMap: <span class="literal">false</span>, <span class="comment">// 生产环境是否生成 SourceMap</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    open: <span class="literal">true</span>, <span class="comment">// 启动服务后是否打开浏览器</span></span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">    port: <span class="number">8080</span>, <span class="comment">// 服务端口</span></span><br><span class="line">    https: <span class="literal">false</span>,</span><br><span class="line">    hotOnly: <span class="literal">false</span>,</span><br><span class="line">    proxy: <span class="literal">null</span>, <span class="comment">// 设置代理</span></span><br><span class="line">    before: <span class="function"><span class="params">app</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue.config.js 还有很多很厉害的配置项</p><p>比如<strong>构建多页面应用</strong>的 <strong>pages</strong>、<strong>改造为 pwa</strong> 的配置项 <strong>pwa</strong>、<strong>高级 CSS 打包方案</strong>  <strong>css</strong> </p><p><strong>五、环境变量</strong></p><p>一个项目通常有三种模式：</p><p><strong>开发模式 development、测试模式 test、生产模式 production</strong></p><p>而开发中通常会根据环境变量 NODE_ENV 来进行区分这三种开发模式</p><p>然后通过很多的 switch… case 来判断</p><p><strong>而 3.x 的项目中就不需要写 switch…case 了</strong></p><p>直接在根目录下创建以 .env 为前缀的文件</p><p><a href="https://www.hualigs.cn/image/nkElB" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/f0728e8b8bcd87f21529b714b2028b06.png" alt="f0728e8b8bcd87f21529b714b2028b06.png"></a></p><p>这里的 .env 文件保存的是公用参数，可以在所有模式中获取到</p><p>而其他文件中的参数，只能在对应模式中获取到</p><p>比如 .env.development 中的参数，就只有在 development 模式下生效</p><p>然后在文件内添加对应的键值对</p><p><a href="https://www.hualigs.cn/image/nkQVj" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/ae14ffa61b74b48d2044f06e6428ca38.png" alt="ae14ffa61b74b48d2044f06e6428ca38.png"></a></p><p>然后在 <strong>package.json</strong> 的 scripts 命令中添加对应的 mode</p><p><a href="https://www.hualigs.cn/image/nkuzM" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/ae2740d6fe3f42a159528ad5e6c5786b.png" alt="ae2740d6fe3f42a159528ad5e6c5786b.png"></a></p><blockquote><p>serve、bulid 都有默认的模式，但最好是将模式显式的展现在配置项中</p></blockquote><p>然后就能在项目中获取到对应模式下的值</p><p><a href="https://www.hualigs.cn/image/nkU7U" target="_blank" rel="noopener"><img src="https://ww1.yunjiexi.club/2019/08/10/ae51a79bad33845ff820ecd61da37992.png" alt="ae51a79bad33845ff820ecd61da37992.png"></a></p><p> 关于环境变量和模式的详情，可以参考<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#模式" target="_blank" rel="noopener">官方文档</a> </p><blockquote><p>转载后修改自：<a href="https://www.cnblogs.com/wisewrong/p/9740173.html" target="_blank" rel="noopener">https://www.cnblogs.com/wisewrong/p/9740173.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue Cli 3 官方文档：&lt;a href=&quot;https://cli.vuejs.org/zh/guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cli.vuejs.org/zh/guide/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、安装 @vue/cli&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更新到 3.x 之后，vue-cli 的包名从 vue-cli 改成了 @vue/cli&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果之前全局安装了旧版本的 vue-cli (1.x 或 2.x)，首先需要使用以下命令卸载掉&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 如果没有安装旧版本的 vue-cli 可以跳过卸载直接安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm uninstall vue-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# OR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yarn global remove vue-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后重新安装新版本的 @vue/cli&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install -g @vue/cli&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# OR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yarn global add @vue/cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://ThisNautilus.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://ThisNautilus.github.io/tags/vue/"/>
    
      <category term="vue cli3" scheme="https://ThisNautilus.github.io/tags/vue-cli3/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目部署至GitHub Pages</title>
    <link href="https://ThisNautilus.github.io/2019/07/02/vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E8%87%B3GitHub%20Pages/"/>
    <id>https://ThisNautilus.github.io/2019/07/02/vue项目部署至GitHub Pages/</id>
    <published>2019-07-02T14:13:22.000Z</published>
    <updated>2019-07-30T14:16:31.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue项目部署至GitHub-Pages"><a href="#Vue项目部署至GitHub-Pages" class="headerlink" title="Vue项目部署至GitHub Pages"></a>Vue项目部署至GitHub Pages</h3><p>1.在 <code>vue.config.js</code> 中设置正确的 <code>publicPath</code>。</p><p>如果打算将项目部署到 <code>https://&lt;USERNAME&gt;.github.io/</code> 上 , <code>publicPath</code> 将默认被设为 <code>&quot;/&quot;</code>，你可以忽略这个参数。</p><p>如果打算将项目部署到 <code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/</code> 上, (换句话说 仓库地址为 <code>https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt;</code>), 可将 <code>publicPath</code> 设为 <code>&quot;/&lt;REPO&gt;/&quot;</code> 。 举个例子， 如果仓库名字为 “my-project”，<code>vue.config.js</code> 的内容应如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line">    ? <span class="string">'/my-project/'</span></span><br><span class="line">    : <span class="string">'/'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：此处是将原来的vue.config.js文件中的所有内容删除，然后复制上述内容进去，修改仓储名称即可</p></blockquote><a id="more"></a><p>2.在项目目录下， 用以下的代码创建 <code>deploy.sh</code>（可以适当地取消注释）并运行它以进行部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当发生错误时中止脚本</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># cd 到构建输出的目录下 </span></span><br><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到自定义域域名</span></span><br><span class="line"><span class="comment"># echo 'www.example.com' &gt; CNAME</span></span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">'deploy'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到 https://&lt;USERNAME&gt;.github.io</span></span><br><span class="line"><span class="comment"># git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;</span></span><br><span class="line"><span class="comment"># git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><blockquote><p>deploy.sh运行方式为：在当前目录下右键<code>Git Bash here</code>,然后输入<code>sh deploy.sh</code>即可</p></blockquote><p>以收银系统为例，运行完成后，在浏览器中输入<code>https://thisnautilus.github.io/cashierdisplay/</code>即可实现所需效果。</p><p>参考链接：<a href="https://cli.vuejs.org/zh/guide/deployment.html#platform-guides" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/deployment.html#platform-guides</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vue项目部署至GitHub-Pages&quot;&gt;&lt;a href=&quot;#Vue项目部署至GitHub-Pages&quot; class=&quot;headerlink&quot; title=&quot;Vue项目部署至GitHub Pages&quot;&gt;&lt;/a&gt;Vue项目部署至GitHub Pages&lt;/h3&gt;&lt;p&gt;1.在 &lt;code&gt;vue.config.js&lt;/code&gt; 中设置正确的 &lt;code&gt;publicPath&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果打算将项目部署到 &lt;code&gt;https://&amp;lt;USERNAME&amp;gt;.github.io/&lt;/code&gt; 上 , &lt;code&gt;publicPath&lt;/code&gt; 将默认被设为 &lt;code&gt;&amp;quot;/&amp;quot;&lt;/code&gt;，你可以忽略这个参数。&lt;/p&gt;
&lt;p&gt;如果打算将项目部署到 &lt;code&gt;https://&amp;lt;USERNAME&amp;gt;.github.io/&amp;lt;REPO&amp;gt;/&lt;/code&gt; 上, (换句话说 仓库地址为 &lt;code&gt;https://github.com/&amp;lt;USERNAME&amp;gt;/&amp;lt;REPO&amp;gt;&lt;/code&gt;), 可将 &lt;code&gt;publicPath&lt;/code&gt; 设为 &lt;code&gt;&amp;quot;/&amp;lt;REPO&amp;gt;/&amp;quot;&lt;/code&gt; 。 举个例子， 如果仓库名字为 “my-project”，&lt;code&gt;vue.config.js&lt;/code&gt; 的内容应如下所示:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  publicPath: process.env.NODE_ENV === &lt;span class=&quot;string&quot;&gt;&#39;production&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ? &lt;span class=&quot;string&quot;&gt;&#39;/my-project/&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：此处是将原来的vue.config.js文件中的所有内容删除，然后复制上述内容进去，修改仓储名称即可&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="实践过程" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/"/>
    
      <category term="项目部署" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="GitHub" scheme="https://ThisNautilus.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>API接口之json-server和JSONPlaceholder</title>
    <link href="https://ThisNautilus.github.io/2019/06/13/API%E6%8E%A5%E5%8F%A3%E4%B9%8B%EF%BC%9Ajson-server%E5%92%8CJSONPlaceholder/"/>
    <id>https://ThisNautilus.github.io/2019/06/13/API接口之：json-server和JSONPlaceholder/</id>
    <published>2019-06-13T03:15:16.000Z</published>
    <updated>2019-08-08T14:46:59.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Json-Server"><a href="#Json-Server" class="headerlink" title="Json-Server"></a>Json-Server</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>需要安装 node.js</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>1.全局安装json-server：<code>npm  install  -g  json-server</code>，可通过<code>json-server -h</code>测试</p><p>2.新建一个文件夹，如JSONSERVER，然后cd  JSONSERVER进入文件夹中.</p><a id="more"></a><p>2.初始化项目 <code>npm init -y</code></p><p>3.安装依赖模块<code>npm install --save-dev json-server</code></p><p>4.在项目根目录下，新建一个 JSON 文件db.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"posts"</span>: [</span><br><span class="line">    &#123; <span class="attr">"id"</span>: <span class="number">1</span>, <span class="attr">"title"</span>: <span class="string">"json-server"</span>, <span class="attr">"author"</span>: <span class="string">"typicode"</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"comments"</span>: [</span><br><span class="line">    &#123; <span class="attr">"id"</span>: <span class="number">1</span>, <span class="attr">"body"</span>: <span class="string">"some comment"</span>, <span class="attr">"postId"</span>: <span class="number">1</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"profile"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"typicode"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.打开 package.json，修改scripts：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "json:server": "json-server --watch db.json"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.启动服务 <code>npm run json:server</code></p><p>至此三个接口已经生成，支持<code>post(新增) delete(删除) put(修改) get(查询)</code>;<br>推荐使用 <code>postman</code> 进行测试</p><p>7.如果想把一个接口中的数据拿过来，可以在package.json文件中进行修改:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "json:server": "json-server --watch db.json"</span><br><span class="line">    "json:server:remote":"json-server http://jsonplaceholder.typicode.com/db"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后重新npm run json:server:remote就可以了。</p><p>8.查看相关内容参考指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有用户信息</span><br><span class="line">http://localhost:3000/users</span><br><span class="line"></span><br><span class="line">// 获取id为1的用户信息</span><br><span class="line">http://localhost:3000/users/1</span><br><span class="line"></span><br><span class="line">// 获取公司的所有信息</span><br><span class="line">http://localhost:3000/companies</span><br><span class="line"></span><br><span class="line">// 获取单个公司的信息</span><br><span class="line">http://localhost:3000/companies/1</span><br><span class="line"></span><br><span class="line">// 获取所有公司id为3的用户</span><br><span class="line">http://localhost:3000/companies/3/users</span><br><span class="line"></span><br><span class="line">// 根据公司名字获取信息</span><br><span class="line">http://localhost:3000/companies?name=Microsoft</span><br><span class="line"></span><br><span class="line">// 根据多个名字获取公司信息</span><br><span class="line">http://localhost:3000/companies?name=Microsoft&amp;name=Apple</span><br><span class="line"></span><br><span class="line">// 获取一页中只有两条数据</span><br><span class="line">http://localhost:3000/companies?_page=1&amp;_limit=2</span><br><span class="line"></span><br><span class="line">// 升序排序 asc升序 desc降序</span><br><span class="line">http://localhost:3000/companies?_sort=name&amp;_order=asc</span><br><span class="line"></span><br><span class="line">// 获取年龄30及以上的</span><br><span class="line">http://localhost:3000/users?age_gte=30</span><br><span class="line"></span><br><span class="line">// 获取年龄在30到40之间</span><br><span class="line">http://localhost:3000/users?age_gte=30&amp;age_lte=40</span><br><span class="line"></span><br><span class="line">// 搜索用户信息</span><br><span class="line">http://localhost:3000/users?q=h  h指的是查询的首字母</span><br></pre></td></tr></table></figure><p>官方文档：<a href="https://www.npmjs.com/package/json-server" target="_blank" rel="noopener">https://www.npmjs.com/package/json-server</a></p><h2 id="JSONPlaceholder"><a href="#JSONPlaceholder" class="headerlink" title="JSONPlaceholder"></a>JSONPlaceholder</h2><p>JSONPlaceholder提供免费的在线REST服务（测试用的HTTP请求假数据）。我们在开发时可以使用它提供的 url 地址测试下网络请求以及请求参数。或者当我们程序需要获取一些假数据、假图片时也可以使用它。</p><p>其返回的数据为 JSON 格式，且同时支持 HTTP 和 HTTPS 这两种请求类型。</p><p>网站地址:<a href="http://jsonplaceholder.typicode.com/" target="_blank" rel="noopener">http://jsonplaceholder.typicode.com/</a></p><p>GitHub:<a href="https://github.com/typicode" target="_blank" rel="noopener">https://github.com/typicode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Json-Server&quot;&gt;&lt;a href=&quot;#Json-Server&quot; class=&quot;headerlink&quot; title=&quot;Json-Server&quot;&gt;&lt;/a&gt;Json-Server&lt;/h2&gt;&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;p&gt;需要安装 node.js&lt;/p&gt;
&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;1.全局安装json-server：&lt;code&gt;npm  install  -g  json-server&lt;/code&gt;，可通过&lt;code&gt;json-server -h&lt;/code&gt;测试&lt;/p&gt;
&lt;p&gt;2.新建一个文件夹，如JSONSERVER，然后cd  JSONSERVER进入文件夹中.&lt;/p&gt;
    
    </summary>
    
      <category term="实践过程" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/"/>
    
      <category term="后端相关" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/%E5%90%8E%E7%AB%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="服务器" scheme="https://ThisNautilus.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="API接口" scheme="https://ThisNautilus.github.io/tags/API%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>json文件搭建本地服务器，以供本地接口获取服务端数据</title>
    <link href="https://ThisNautilus.github.io/2019/06/12/json%E6%96%87%E4%BB%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E4%BB%A5%E4%BE%9B%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE/"/>
    <id>https://ThisNautilus.github.io/2019/06/12/json文件搭建本地服务器，以供本地接口获取服务端数据/</id>
    <published>2019-06-12T13:14:12.000Z</published>
    <updated>2019-07-30T11:20:33.391Z</updated>
    
    <content type="html"><![CDATA[<p>利用<strong>node.js + http-server + 本地json文件</strong>搭建一个本地服务器，以供本地接口获取服务端数据</p><h4 id="准备本地json文件"><a href="#准备本地json文件" class="headerlink" title="准备本地json文件"></a>准备本地json文件</h4><ul><li>json文件可以手动编辑，也可以从免费接口获取。如：test.json</li><li>新建文件夹localserver，将test.json移动至此</li></ul><a id="more"></a><h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><h4 id="全局安装本地服务器"><a href="#全局安装本地服务器" class="headerlink" title="全局安装本地服务器"></a>全局安装本地服务器</h4><p><code>npm install http-server -g</code></p><h4 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h4><ul><li><p>切换至localserver文件夹，<code>shift</code>加鼠标右键在此打开cmd命令行</p></li><li><p>输入<code>http-server</code>即启动本地服务器，地址会在下方命令行显示：</p><p>如：<code>http://127.0.0.1:8080</code></p></li><li><p>打开浏览器，输入<code>http://127.0.0.1:8080/test.json</code>即可。</p></li></ul><p>参考链接：<a href="https://blog.csdn.net/ZHOUYANFEN_A/article/details/82661991" target="_blank" rel="noopener">https://blog.csdn.net/ZHOUYANFEN_A/article/details/82661991</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用&lt;strong&gt;node.js + http-server + 本地json文件&lt;/strong&gt;搭建一个本地服务器，以供本地接口获取服务端数据&lt;/p&gt;
&lt;h4 id=&quot;准备本地json文件&quot;&gt;&lt;a href=&quot;#准备本地json文件&quot; class=&quot;headerlink&quot; title=&quot;准备本地json文件&quot;&gt;&lt;/a&gt;准备本地json文件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;json文件可以手动编辑，也可以从免费接口获取。如：test.json&lt;/li&gt;
&lt;li&gt;新建文件夹localserver，将test.json移动至此&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="实践过程" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/"/>
    
      <category term="后端相关" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/%E5%90%8E%E7%AB%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="服务器" scheme="https://ThisNautilus.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="API接口" scheme="https://ThisNautilus.github.io/tags/API%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>本地服务器接口搭建</title>
    <link href="https://ThisNautilus.github.io/2019/06/12/%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%90%AD%E5%BB%BA/"/>
    <id>https://ThisNautilus.github.io/2019/06/12/本地服务器接口搭建/</id>
    <published>2019-06-12T13:13:12.000Z</published>
    <updated>2019-07-30T14:31:32.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><ol><li>完整的操作页面</li><li>首页展示所有保存的接口列表</li><li>创建的接口保存到本地</li><li>支持重新编辑</li><li>编辑过程实时预览和错误提示</li><li>根据接口名称或者url进行检索</li><li>提供url跨域调用</li></ol><blockquote><p>下载完成安装依赖就可使用:选中jsonServer–右键open with vscode–npm install</p></blockquote><a id="more"></a><h3 id="模拟数据接口实现方式"><a href="#模拟数据接口实现方式" class="headerlink" title="模拟数据接口实现方式"></a>模拟数据接口实现方式</h3><ul><li>1.直接代码里面js本地造数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var data = &#123;...&#125;</span><br><span class="line">...</span><br><span class="line">//这种方案适合小型结构的数据，一旦数据过于庞大，不适合放在js文件里面，不利于维护</span><br><span class="line">//不能很好的模拟ajax</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&apos;..&apos;//这个时候ajax接口不存在，调不通</span><br><span class="line">&#125;)</span><br><span class="line">//不能重复利用，上生产肯定要删掉</span><br></pre></td></tr></table></figure><ul><li>使用mock.js生成随机数据，拦截 Ajax 请求<a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a></li></ul><h3 id="实现本地化接口服务"><a href="#实现本地化接口服务" class="headerlink" title="实现本地化接口服务"></a>实现本地化接口服务</h3><p>本文介绍了一个简单的平台化方案，创建一个本地化的服务系统，这样得到数据格式之后，本地生成一个可用的 <code>url</code> 用于<code>ajax</code>请求，而且还可以让数据持久化，如果放在局域网内，接口还可以共享给小伙伴。</p><p>说到持久化，那么必须涉及到数据的存储，用于存储的数据库有很多，我以前用过<code>mongodb</code>结合<code>nodejs</code>使用，也是蛮好的，但是数据库安装也蛮麻烦的，我们这里有一个更简便的，硬盘本身就是一个<code>“数据库”</code> ，所以我们可以使用<code>nodejs</code>的<code>fs</code>模块直接创建<code>json</code>文件，读取<code>json</code>文件。这样创建的每一个<code>json</code>文件都对于一个接口服务，只要不删除，就可以一直重复利用。</p><h3 id="使用方法介绍"><a href="#使用方法介绍" class="headerlink" title="使用方法介绍"></a>使用方法介绍</h3><ol><li><p><code>github</code>下载源码，并执行 <code>npm install</code> 安装</p><blockquote><p><a href="https://github.com/kliuj/local-ajax-api" target="_blank" rel="noopener">https://github.com/kliuj/local-ajax-api</a></p></blockquote></li><li><p>启动node服务，<code>node app.js</code>。 （建议使用 <code>supervisor app.js</code> 可以自行重启服务，通过<code>npm install supervisor -g</code> 安装模块）</p></li><li><p>打开首页 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> <code>建议chrome浏览器查看</code></p><p><img src="https://segmentfault.com/img/bVE9Vy?w=1287&h=503" alt="clipboard.png"></p></li><li><p>点击创建接口，<code>API</code>名称用来描述接口左右，<code>API url</code>用来调用数据，都是必填。如图，我们创建一个接口 <code>testapi</code> 可以实时预览格式化的json数据和提示错误。（建议使用网上更完整的工具预览，可以快速定位格式错误。）</p><blockquote><p>API url这一栏填写单词就行</p></blockquote><p><img src="https://segmentfault.com/img/bVFnCe?w=1238&h=459" alt="图片描述"></p><p>创建完成点击最下面的保存按钮，提示保存成功就完成了接口的创建！</p></li><li><p>使用接口，根据刚刚创建的<code>url：testapi</code> 生成一个链接 <a href="http://localhost:3000/getjson/testapi" target="_blank" rel="noopener">http://localhost:3000/getjson…</a><br>可以在控制台调用一下这个<code>url</code>可以看出就是我们刚刚存储的<code>json</code>数据。<br><img src="https://segmentfault.com/img/bVE9Xs?w=813&h=97" alt="clipboard.png"></p></li><li><p>搜索功能：在搜索框输入接口中文描述名称或者<code>apiurl</code>的名称即可。</p></li><li><p>二次编辑功能：创建完成接口之后，首页或者搜索结果会显示二次编辑入口，点击就会显示上次保存的数据和格式</p><p><img src="https://segmentfault.com/img/bVE9X0?w=1223&h=467" alt="clipboard.png"></p></li><li><p>注意：<code>ajaxapilist.json</code> 存着一张关系表，对应所有的接口描述名称和<code>url</code>，用于查询，建议不要修改。</p></li></ol><blockquote><p>使用说明文档：<a href="https://segmentfault.com/a/1190000007387454" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007387454</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现功能&quot;&gt;&lt;a href=&quot;#实现功能&quot; class=&quot;headerlink&quot; title=&quot;实现功能&quot;&gt;&lt;/a&gt;实现功能&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;完整的操作页面&lt;/li&gt;
&lt;li&gt;首页展示所有保存的接口列表&lt;/li&gt;
&lt;li&gt;创建的接口保存到本地&lt;/li&gt;
&lt;li&gt;支持重新编辑&lt;/li&gt;
&lt;li&gt;编辑过程实时预览和错误提示&lt;/li&gt;
&lt;li&gt;根据接口名称或者url进行检索&lt;/li&gt;
&lt;li&gt;提供url跨域调用&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;下载完成安装依赖就可使用:选中jsonServer–右键open with vscode–npm install&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="实践过程" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/"/>
    
      <category term="后端相关" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/%E5%90%8E%E7%AB%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="服务器" scheme="https://ThisNautilus.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="API接口" scheme="https://ThisNautilus.github.io/tags/API%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中on事件与addEventListener()</title>
    <link href="https://ThisNautilus.github.io/2019/05/12/JavaScript%E4%B8%ADon%E4%BA%8B%E4%BB%B6%E4%B8%8EaddEventListener()/"/>
    <id>https://ThisNautilus.github.io/2019/05/12/JavaScript中on事件与addEventListener()/</id>
    <published>2019-05-12T11:13:29.000Z</published>
    <updated>2019-08-13T02:23:02.599Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>onclick()这种写法是DOM0级规范的写法，是所有的浏览器支持的，但是这种写法有<strong>不能同时绑定多个事件</strong>、使代码耦合在了一起的弊端。</p></li><li><p>addEventListener() 是DOM2标准中定义的方法，它可以控制是在事件捕获阶段或者是在冒泡阶段调用事件处理程序。只有支持DOM2级事件处理程序的浏览器才支持这个方法（IE9+）。</p></li><li><p><a href="https://www.zhihu.com/question/56814906/answer/150530726" target="_blank" rel="noopener">原生addEventListener比<strong>jQuery中的on</strong>慢了60倍</a>，本文中的on为原生的“on + 事件”。</p></li></ul><a id="more"></a><p><strong>addEventListener()</strong>和<strong>on</strong>的区别要从<strong>事件侦听</strong>（Event Listeners）和<strong>内联事件</strong>(Inline Events)说起，下面以demo代码演示。</p><h2 id="事件侦听（Event-Listeners）"><a href="#事件侦听（Event-Listeners）" class="headerlink" title="事件侦听（Event Listeners）"></a>事件侦听（Event Listeners）</h2><p><strong>EventTarget.addEventListener()</strong> 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 </p><p>事件目标可以是一个文档上的元素 Document 本身，或者任何其他支持事件的对象 (比如 XMLHttpRequest)。</p><h3 id="addEventListener语法"><a href="#addEventListener语法" class="headerlink" title="addEventListener语法"></a>addEventListener语法</h3><p><strong>element.addEventListener(event, function, useCapture)</strong></p><p>参数 event：表示监听事件类型的字符串（必须）；</p><p>参数 function：一个实现了 EventListener 接口的对象，或者是一个函数（必须）；</p><p>参数 useCapture：布尔值，指定事件是否在捕获或冒泡阶段执行（可选）；</p><p>useCapture可能值（事件冒泡，稍后介绍）：</p><ul><li><p><strong>true - 事件句柄在捕获阶段执行</strong>；</p></li><li><p>false- 默认。事件句柄在冒泡阶段执行；</p></li></ul><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line">    <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);     </span><br><span class="line">    box.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;         </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是box1"</span>);     </span><br><span class="line">    &#125;)     </span><br><span class="line">    box.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;         </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是box2"</span>);     </span><br><span class="line">    &#125;) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//运行结果： </span></span><br><span class="line"><span class="comment">//我是box1 </span></span><br><span class="line"><span class="comment">//我是box2</span></span><br></pre></td></tr></table></figure><h3 id="addEventListener特点"><a href="#addEventListener特点" class="headerlink" title="addEventListener特点"></a>addEventListener特点</h3><p>addEventListener 是 W3C DOM 规范中提供的注册事件监听器的方法。它的优点包括：</p><ul><li>允许给一个事件注册多个 listener。当存在其他的库时，使用 DHTML 库或者 Mozilla extensions 不会出现问题。</li><li>提供了一种更精细的手段控制 listener 的触发阶段。（即可以选择捕获或者冒泡）。</li><li>对任何 DOM 元素都是有效的，而不仅仅只对 HTML 元素有效。</li></ul><h2 id="内联事件-Inline-Events"><a href="#内联事件-Inline-Events" class="headerlink" title="内联事件(Inline Events)"></a>内联事件(Inline Events)</h2><p>由于内联事件是作为元素属性保存起来的，这些属性可以被覆盖，所以如果为同一个事件绑定了多个处理程序，那么最后一个处理程序会覆盖之前的程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line">    <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);     </span><br><span class="line">    box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;         </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是box1"</span>);     </span><br><span class="line">    &#125;     </span><br><span class="line">    box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;         </span><br><span class="line">        box.style.fontSize = <span class="string">"18px"</span>;         </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是box2"</span>);     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//运行结果： </span></span><br><span class="line"><span class="comment">//我是box2  </span></span><br><span class="line"><span class="comment">//覆盖了前者</span></span><br></pre></td></tr></table></figure><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>点击div里a标签，触发了div的点击事件？这就是JS事件冒泡。JS事件冒泡分向上冒泡、向下冒泡；</p><p>好吧，有时候JS事件冒泡是我们想要的，有时候JS事件冒泡是讨厌的，Web前端开发者需根据项目实际情况处理。</p><h3 id="向上冒泡"><a href="#向上冒泡" class="headerlink" title="向上冒泡"></a>向上冒泡</h3><p>即：从子元素再到父元素冒泡，默认情况事件是按照事件冒泡的执行顺序进行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">box.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"box"</span>); </span><br><span class="line">&#125;) </span><br><span class="line">child.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"child"</span>); </span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">//执行的结果： </span></span><br><span class="line"><span class="comment">//child </span></span><br><span class="line"><span class="comment">//box</span></span><br></pre></td></tr></table></figure><p>如何做到从父元素向子元素的顺序冒泡呢？下面有请 addEventListener 闪亮登场<strong>添加true</strong>！</p><h3 id="向下冒泡"><a href="#向下冒泡" class="headerlink" title="向下冒泡"></a>向下冒泡</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">box.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"box"</span>); </span><br><span class="line">&#125;,<span class="literal">true</span>)  <span class="comment">//关键true </span></span><br><span class="line">child.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"child"</span>); </span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">//执行的结果： </span></span><br><span class="line"><span class="comment">//box </span></span><br><span class="line"><span class="comment">//child</span></span><br></pre></td></tr></table></figure><p>addEventListener()方法中的第三个参数true是向下冒泡的关键，它规定事件句柄在捕获阶段执行。</p><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p>兼容性一直是程序员须警惕的，不过现在大可不必太过惧怕IE8及早期浏览器了，毕竟它们正在消亡！</p><p>简单封装，兼顾一下IE8及早期浏览器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, evnt, func</span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (element.attachEvent)&#123; <span class="comment">// IE8及更低版本浏览器    </span></span><br><span class="line">        <span class="keyword">return</span> element.attachEvent(<span class="string">'on'</span>+evnt, func);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// IE8+，或其它现代浏览器    </span></span><br><span class="line">        <span class="keyword">return</span> element.addEventListener(evnt, func, <span class="literal">false</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">//调用 </span></span><br><span class="line">addEvent(<span class="built_in">document</span>.getElementById(<span class="string">'element'</span>),<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;        </span><br><span class="line">    <span class="comment">// some code here    </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;onclick()这种写法是DOM0级规范的写法，是所有的浏览器支持的，但是这种写法有&lt;strong&gt;不能同时绑定多个事件&lt;/strong&gt;、使代码耦合在了一起的弊端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;addEventListener() 是DOM2标准中定义的方法，它可以控制是在事件捕获阶段或者是在冒泡阶段调用事件处理程序。只有支持DOM2级事件处理程序的浏览器才支持这个方法（IE9+）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/56814906/answer/150530726&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原生addEventListener比&lt;strong&gt;jQuery中的on&lt;/strong&gt;慢了60倍&lt;/a&gt;，本文中的on为原生的“on + 事件”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ThisNautilus.github.io/categories/JavaScript/"/>
    
      <category term="DOM" scheme="https://ThisNautilus.github.io/categories/JavaScript/DOM/"/>
    
    
      <category term="JavaScript" scheme="https://ThisNautilus.github.io/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://ThisNautilus.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>SublimeText3插件安装</title>
    <link href="https://ThisNautilus.github.io/2019/05/02/SublimeText3%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>https://ThisNautilus.github.io/2019/05/02/SublimeText3插件安装/</id>
    <published>2019-05-02T01:14:12.000Z</published>
    <updated>2019-07-30T11:26:57.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件下载"><a href="#1-软件下载" class="headerlink" title="1.软件下载"></a>1.软件下载</h3><p>中文网址<a href="http://www.sublimetext.cn/" target="_blank" rel="noopener">http://www.sublimetext.cn/</a>，下载sublimetext3</p><a id="more"></a><h3 id="2-软件配置"><a href="#2-软件配置" class="headerlink" title="2.软件配置"></a>2.软件配置</h3><p>中文文档：<a href="http://packagecontrol.cn/installation" target="_blank" rel="noopener">http://packagecontrol.cn/installation</a></p><p>由于packagecontrol.io被墙，所以安装Sublime Text需要两步：</p><p>第一步：通过控制台安装插件代码，通过 ctrl<em>+</em>` 或 View <em>&gt;</em> Show Console打开控制台，将Python代码粘贴到控制台，回车。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.cn/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure><p>第二步：修改Sublime Text插件channels，方法如下：</p><p>1、打开Package Control配置文件PackageSetings—-PackageControl—-Setings-User</p><p>2、修改或新增channels地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;channels&quot;: [ &quot;http://packagecontrol.cn/channel_v3.json&quot; ] &#125;</span><br></pre></td></tr></table></figure><p>保存搞定！</p><h3 id="3-插件安装"><a href="#3-插件安装" class="headerlink" title="3.插件安装"></a>3.插件安装</h3><p>插件安装过程：</p><ul><li>按下Ctrl+Shift+P调出命令面板。</li><li>输入install 调出 Install Package 选项并回车，然后在列表中输入并选中要安装的插件。</li><li>安装过程中可以：按Ctrl+ `(此符号为tab按键上面的按键) 调出console来查看安装进度</li></ul><p>插件选择：参照<a href="https://www.cnblogs.com/qingkong/p/5039527.html" target="_blank" rel="noopener">https://www.cnblogs.com/qingkong/p/5039527.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-软件下载&quot;&gt;&lt;a href=&quot;#1-软件下载&quot; class=&quot;headerlink&quot; title=&quot;1.软件下载&quot;&gt;&lt;/a&gt;1.软件下载&lt;/h3&gt;&lt;p&gt;中文网址&lt;a href=&quot;http://www.sublimetext.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.sublimetext.cn/&lt;/a&gt;，下载sublimetext3&lt;/p&gt;
    
    </summary>
    
      <category term="实践过程" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/"/>
    
      <category term="软件配置" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Sublime" scheme="https://ThisNautilus.github.io/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置注意事项</title>
    <link href="https://ThisNautilus.github.io/2019/05/01/Hexo%E9%85%8D%E7%BD%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://ThisNautilus.github.io/2019/05/01/Hexo配置注意事项/</id>
    <published>2019-05-01T03:16:12.000Z</published>
    <updated>2019-07-30T11:27:23.171Z</updated>
    
    <content type="html"><![CDATA[<p> 以下为搭建博客过程中踩的一些坑。</p><a id="more"></a><h3 id="设置侧边栏菜单"><a href="#设置侧边栏菜单" class="headerlink" title="设置侧边栏菜单"></a>设置侧边栏菜单</h3><p>通过<a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> 来配置侧边栏菜单图标时，可能会出现图标不显示的情况，此时只需在<a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> 中复制其他同类图标即可。</p><h3 id="避免每次提交输入账号密码"><a href="#避免每次提交输入账号密码" class="headerlink" title="避免每次提交输入账号密码"></a>避免每次提交输入账号密码</h3><p>将<code>repo: https://github.com/ThisNautilus/ThisNautilus.github.io.git</code></p><p>替换为<code>repo: git@github.com:ThisNautilus/ThisNautilus.github.io.git</code></p><h3 id="提交博客步骤"><a href="#提交博客步骤" class="headerlink" title="提交博客步骤"></a>提交博客步骤</h3><blockquote><p>注意：提交前先clean</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h3 id="生成about页面"><a href="#生成about页面" class="headerlink" title="生成about页面"></a>生成about页面</h3><p>也称为：利用hexo的page功能实现保留页面<br><code>hexo n page about</code><br>新建一个标题为 about 的页面，默认链接地址为 <code>主页地址/about/</code></p><ul><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul><h3 id="生成categories页面"><a href="#生成categories页面" class="headerlink" title="生成categories页面"></a>生成categories页面</h3><p>添加标签页面，前面通过修改next主题下的<code>_config.yml</code>文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面</p><p><code>hexo new page categories</code></p><p>在生成的index.md文件中添加<code>type: categories</code></p><blockquote><p>注意：之后要留空格</p></blockquote><h3 id="生成tags页面"><a href="#生成tags页面" class="headerlink" title="生成tags页面"></a>生成tags页面</h3><p>添加标签页面，前面通过修改next主题下的<code>_config.yml</code>文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面</p><p><code>hexo new page tags</code></p><p>在生成的index.md文件中添加<code>type: tags</code></p><h3 id="如何让博文列表不显示全部内容"><a href="#如何让博文列表不显示全部内容" class="headerlink" title="如何让博文列表不显示全部内容"></a>如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p><p>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可</p><p><strong>注意，实际插入的时候<!--more-->不要加反引号</strong></p><h3 id="参考帖子"><a href="#参考帖子" class="headerlink" title="参考帖子"></a>参考帖子</h3><ul><li>Hexo官方文档：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></li><li>Next主题官方文档：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></li><li>某博客：<a href="https://blog.enjoytoshare.club/" target="_blank" rel="noopener">https://blog.enjoytoshare.club/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 以下为搭建博客过程中踩的一些坑。&lt;/p&gt;
    
    </summary>
    
      <category term="实践过程" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/"/>
    
      <category term="软件配置" scheme="https://ThisNautilus.github.io/categories/%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Hexo" scheme="https://ThisNautilus.github.io/tags/Hexo/"/>
    
      <category term="Markdown" scheme="https://ThisNautilus.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="https://ThisNautilus.github.io/2019/04/20/Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://ThisNautilus.github.io/2019/04/20/Markdown语法/</id>
    <published>2019-04-20T02:46:12.000Z</published>
    <updated>2019-07-29T23:52:11.741Z</updated>
    
    <content type="html"><![CDATA[<p><strong>常用Markdown语法</strong></p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br><span class="line">或者</span><br><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure><h3 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片名称](图片链接地址)</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 前端学习之路</span><br></pre></td></tr></table></figure><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**粗体**</span><br><span class="line">*斜体*</span><br></pre></td></tr></table></figure><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`代码段`</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​</span><br></pre></td></tr></table></figure><p>整段代码<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 表格</span><br></pre></td></tr></table></figure></p><p>语法：<br>|排名|公司名称|主要产品|<br>|—|—|—|<br>|1|阿里巴巴|淘宝、天猫、支付宝|<br>|2|腾讯|QQ、微信、TIM|<br>|3|字节跳动|今日头条、火山小视频、抖音|</p><pre><code>| 排名 | 公司名称 |          主要产品          || :--: | :------: | :------------------------: ||  1   | 阿里巴巴 |     淘宝、天猫、支付宝     ||  2   |   腾讯   |       QQ、微信、TIM        ||  3   | 字节跳动 | 今日头条、火山小视频、抖音 |</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;常用Markdown语法&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="使用方法" scheme="https://ThisNautilus.github.io/categories/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Markdown" scheme="https://ThisNautilus.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
